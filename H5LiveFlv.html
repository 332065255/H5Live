<!DOCTYPE html>
<!--
	作者：332065255@qq.com
	时间：2016-06-22
	描述：   h5 播放flv 直播测试
-->
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
		<style>
			*{
				padding: 0px;
				margin: 0px;
			}
			html,body{
				width: 100%;
				height: 100%;
			}
		</style>
		<script type="text/javascript" src="js/flvdemux.js" ></script>
		<script type="text/javascript" src="js/mp4mux.js" ></script>
		<!--<script type="text/javascript" src="js/flv2mp4.js" ></script>-->
		<script>
			var elem;
			window.onload = function() {
			    elem = document.getElementById("pchVideo");
				streamingDemo();
				elem.addEventListener("loadedmetadata",loadedmetadata)
				elem.addEventListener("timeupdate",timeupdate)
				elem.addEventListener('ended',this.endFun,false)
				
				elem.addEventListener('error',this.errorFun,false);
			};
			function endFun(){
				console.log("stop")
			}
			function errorFun(e){
				console.log("error",e,elem.error)
				
			}
			function timeupdate(){
				var div=document.getElementById("timeCurren");
				div.innerHTML=parseInt(elem.currentTime);
			}
			function loadedmetadata(){
				var div=document.getElementById("time");
				div.innerHTML="/"+parseInt(elem.duration);
			}
			var mediaSource;
			function streamingDemo() {  
				mediaSource= new MediaSource;

				  blobs=new Blob([]);
				  elem.src = URL.createObjectURL(mediaSource);
				  elem.play();
				  mediaSource.addEventListener('sourceopen', sourceOpen);
//					sourceOpen();
				
			}
			var soFar=0;
			var _this=this;
			var blobs;
			//没用完的mp4数据集合
			var arr=[];
			//整理好的tag集合
			var arrTag=[];
			//第一个metadata tag,第一个视频tag,第一个音频tag  集合
			var arrMetaTag=[];
			//半截tag集合
			var arrTempCache=[];
			//临时储存u8a
			var arrTemp=[];
			//是否读完了第一个MAV
			var fristMoov=true;
			//是否赋值了MAV
			var fristMoovSet=false;
			//解码open;
			var decodeOpen=true;
			//临时tag
			var tempTag=[];
			
			var testIndex=0;
			
			var videoTrackF={};
			var audioTrackF={};
			
			var sclas=1;
			var firstSet=false;
			function readr(reader){
				return reader.read().then(function (result) {
		            
            			const chunk = result.value;///Uint8Array

					if (result.done) {
		                console.log("this's over");
//		                _this.mediaSource.endOfStream();
		                return reader.cancel();
		            }
            			soFar += chunk.byteLength;
//          			if(soFar>50000)
//          			{
//          				_this.Progresss(new Uint8Array(arrTempCache))
						_this.Progresss(chunk);
//          				arrTempCache=[];
//          				soFar=0;
//          			}
//          			else
//          			{
//          				
//          				arrTempCache=arrTempCache.concat(_this.Uint8Array2Array(chunk))
//          				console.log(soFar,arrTempCache.length)
//          				return _this.readr(reader);
//          			}
//          			console.log(soFar,"current",chunk.byteLength);
            			
            			if(_this.arrMetaTag.length>3&&!fristMoovSet)
            			{
            				console.log(_this.arrMetaTag);
            				var arrT=[];
            				for(var i=0;i<_this.arrMetaTag.length;i++)
            				{
            					arrT=arrT.concat(_this.arrMetaTag[i]);
            				}
            				let parser = new InitSegmentParser();
            				
            				let flvhdr=parser.push(new Uint8Array(arrT))
//          				console.log(flvhdr);
            				let stream=flvhdr
            				stream.duration = stream.meta.duration;
            				stream.duration=stream.duration==0?3600:stream.duration;
            				stream.timeStart = 0;
						stream.timeEnd = stream.duration;
            				
            				let record = flvhdr.firstv.AVCDecoderConfigurationRecord;
						console.log('probe:', `h264.profile=${record[1].toString(16)}`, 'meta', flvhdr);
		
						this.videoTrack = {
							type: 'video',
							id: 1,
							duration: 0,
							width: flvhdr.meta.width,
							height: flvhdr.meta.height,
							AVCDecoderConfigurationRecord: flvhdr.firstv.AVCDecoderConfigurationRecord,
						};
						_this.videoTrackF=videoTrack;
						this.audioTrack = {
							type: 'audio',
							id: 2,
							duration: this.videoTrack.duration,
							channelcount: flvhdr.firsta.channelCount,
							samplerate: flvhdr.firsta.sampleRate,
							samplesize: flvhdr.firsta.sampleSize,
							AudioSpecificConfig: flvhdr.firsta.AudioSpecificConfig,
						};
						_this.audioTrackF=audioTrack;
//						console.log(this.videoTrack,this.audioTrack)
//						sclas=mp4mux.timeScale
						var result=mp4mux.initSegment([this.videoTrack, this.audioTrack], stream.duration*mp4mux.timeScale)
//						console.log(result);
						_this.sourceBuffer.appendBuffer(result);
//						stream.timeStart = this.duration;
//						stream.timeEnd = this.duration+stream.duration;
//						stream.indexStart = this.keyframes.length;
            				
            				fristMoovSet=true;
//          				console.log("执行了metadata的赋值","余下数据量",_this.arrTemp.length)
//          				return reader.cancel();
            			}
            			else if(_this.arrMetaTag.length>3&&_this.arrTag.length>0)
            			{
            				testIndex+=1;
            				
            				let segpkts = parseMediaSegment(new Uint8Array(_this.arrTag));
//          				console.log(segpkts)
            				var u8arr=(_this.decodeflv2Mp4(segpkts));
//          				
            				_this.arrTag=[];
            				
            				
            				if(!_this.sourceBuffer.updating&&_this.arr.length==0)
						{
//							_this.arr=_this.arr.concat(_this.Uint8Array2Array(u8arr))
//							_this.arr.push(_this.Uint8Array2Array(u8arr))
//							var u8a=new Uint8Array(_this.arr.shift());//拿出所有完整的tag
////							_this.arrTag=[];
							_this.sourceBuffer.appendBuffer(u8arr);
//							_this.arr=[];
							console.log("执行成功一次",_this.sourceBuffer.buffered);
//							firstSet=true;
//							for(var i=0;i<_this.sourceBuffer.buffered.length;i++)
//							{
//								console.log("start",_this.sourceBuffer.buffered.start(i),"end",_this.sourceBuffer.buffered.end(i))
//							}
							
						}
						else
						{
//							_this.arr=_this.arr.concat(_this.Uint8Array2Array(u8arr))
							_this.arr.push(_this.Uint8Array2Array(u8arr));
							console.log("还在更新呢",_this.sourceBuffer.buffered);
//							for(var i=0;i<_this.sourceBuffer.buffered.length;i++)
//							{
//								console.log("start",_this.sourceBuffer.buffered.start(i),"end",_this.sourceBuffer.buffered.end(i))
//							}
						}
            			}
            			
//          			if(testIndex==100)
//          			{
//          				return reader.cancel();
//          			}
//          			console.log(_this.sourceBuffer.appendBuffer)
					
            			
            			
//          			console.log(soFar);
            			return _this.readr(reader);
            	})
			}
			function sourceBufferOnUpdateend(){
				if(_this.arr.length>0)
				{
					var u8a=new Uint8Array(_this.arr.shift());//拿出所有完整的tag
	//							_this.arrTag=[];
					_this.sourceBuffer.appendBuffer(u8a.buffer);
				}
			}
			let lastVSample, lastVDuration, vduration;
			let lastASample, lastADuration, aduration;
			//主体解码flv2mp4
			function decodeflv2Mp4(segpkts){
				let videoTrack = _this.videoTrackF;
				let audioTrack = _this.audioTrackF;
				
				videoTrack._mdatSize = 0;
				videoTrack.samples = [];
				audioTrack._mdatSize = 0;
				audioTrack.samples = [];
				
				
				for(var i=0;i<segpkts.length;i++)
				{
					if(segpkts[i].type=='video'&&segpkts[i].NALUs)
					{
						delete videoTrack._firstTime;
					}
				}
				for(var i=0;i<segpkts.length;i++)
				{
					if(segpkts[i].type=='audio'&&segpkts[i].frame)
					{
						delete audioTrack._firstTime;
					}
				}
				segpkts.filter(pkt => pkt.type == 'video' && pkt.NALUs).forEach((pkt, i) => {
					let sample = {};
					sample._data = pkt.NALUs;
					sample._offset = videoTrack._mdatSize;
					sample.size = sample._data.byteLength;
					videoTrack._mdatSize += sample.size;
					
					if (videoTrack._firstTime === undefined) {
						videoTrack._firstTime = pkt.dts*sclas;
					}
					sample._dts = pkt.dts*sclas;
					sample.compositionTimeOffset = pkt.cts*mp4mux.timeScale;
		
					sample.flags = {
						isLeading: 0,
						dependsOn: 0,
						isDependedOn: 0,
						hasRedundancy: 0,
						paddingValue: 0,
						isNonSyncSample: pkt.isKeyFrame?0:1,
						degradationPriority: 0,
					};
//					console.log("视频tags的当前时间轴",sample._dts)
					if (lastVSample) {
						let diff = sample._dts-lastVSample._dts;
						lastVSample.duration = diff*mp4mux.timeScale;
						vduration += diff;
						lastVDuration = diff;
					}
					lastVSample = sample;
					videoTrack.samples.push(sample);
				});
				lastVSample.duration = lastVDuration*mp4mux.timeScale;
				videoTrack._lastTime = (lastVSample._dts+lastVDuration)*sclas;
				
				aduration = 0;
				segpkts.filter(pkt => pkt.type == 'audio' && pkt.frame).forEach((pkt, i) => {
					let sample = {};
					sample._data = pkt.frame;
					sample._offset = audioTrack._mdatSize;
					sample.size = sample._data.byteLength;
					audioTrack._mdatSize += sample.size;
		
					//dbp('audiosample', pkt.dts, pkt.frame.byteLength);
		
					if (audioTrack._firstTime === undefined) {
						audioTrack._firstTime = pkt.dts;
					}
					sample._dts = pkt.dts;
		
					if (lastASample) {
						let diff = sample._dts-lastASample._dts;
						lastASample.duration = diff*mp4mux.timeScale;
						aduration += diff;
						lastADuration = diff;
					}
					lastASample = sample;
					audioTrack.samples.push(sample);
				});
				if(lastASample)
				lastASample.duration = lastADuration*mp4mux.timeScale;
				audioTrack._lastTime = aduration+lastADuration+audioTrack._firstTime;
				
				videoTrack.baseMediaDecodeTime = videoTrack._firstTime*mp4mux.timeScale;
				if(audioTrack._firstTime===undefined)
				audioTrack.baseMediaDecodeTime = 0;
				else
				audioTrack.baseMediaDecodeTime = audioTrack._firstTime*mp4mux.timeScale;
				
				let moof, _mdat, mdat;
				let list = [];
//				console.log("视频包开始时间",videoTrack._firstTime,"视频包结束时间",videoTrack._lastTime,"音频包开始时间",audioTrack._firstTime,"音频包结束时间",audioTrack._lastTime,"视频包大小",videoTrack._mdatSize,"音频包大小",audioTrack._mdatSize)
				moof = mp4mux.moof(0, [videoTrack]);
				_mdat = new Uint8Array(videoTrack._mdatSize);
				videoTrack.samples.forEach(sample => _mdat.set(sample._data, sample._offset));
				mdat = mp4mux.mdat(_mdat);
				list = list.concat([moof, mdat]);
		
				moof = mp4mux.moof(0, [audioTrack]);
				_mdat = new Uint8Array(audioTrack._mdatSize);
				audioTrack.samples.forEach(sample => _mdat.set(sample._data, sample._offset));
				mdat = mp4mux.mdat(_mdat);
				list = list.concat([moof, mdat]);
		
				return concatUint8Array(list);
			}
			function concatUint8Array(list) {
				let len = 0;
				list.forEach(b => len += b.byteLength)
				let res = new Uint8Array(len);
				let off = 0;
				list.forEach(b => {
					res.set(b, off);
					off += b.byteLength;
				})
				return res;
			}
			function Progresss(u8a){
				_this.arrTemp=_this.arrTemp.concat(_this.Uint8Array2Array(u8a))
				if(_this.fristMoov&&!fristMoovSet)
				{
					if(_this.arrTemp.length>24)///保证flv的header和metadata的tag header是存在的
					{
						fristMoov=fristMAV(_this.arrTemp)
						return fristMoov;
					}
					return false;
				}
				else
				{
					decodeOpen=true;
					_this.getMAV(_this.arrTemp);
//					console.log("走其余的tag")
				}
			}
			//第一个metadata,视频tag,音频tag是否读完
			function fristMAV(u8a){
				//拿出flv header
				if(_this.arrMetaTag.length<1)
				{
					var header=[];
					for(var i=0;i<13;i++)
					{
						header.push(_this.arrTemp.shift());
					}
					_this.arrMetaTag.push(header);
				}
				//拿出metadata
				if(_this.arrMetaTag.length<2)
				{
					
					var meta=[];
					for(i=0;i<11;i++)
					{
						meta.push(_this.arrTemp.shift())
					}
					var bodySize=_this.getBodySize(meta);
					if(_this.arrTemp.length>=(bodySize+4))
					{
						for(i=0;i<(bodySize+4);i++)
						{
							meta.push(_this.arrTemp.shift())
						}
						_this.arrMetaTag.push(meta);
					}
					else
					{
						//如果包体没有那么大,就把临时数组还原,等下次再解析
						_this.arrTemp=meta.concat(_this.arrTemp);
						return false;
					}
				}
				//拿出音频或者视频
				if(_this.arrMetaTag.length<3)
				{
					var Atag=[];
					if(_this.arrTemp.length>11)
					{
						for(i=0;i<11;i++)
						{
							Atag.push(_this.arrTemp.shift())
						}
					}
					else
					{
						return false;
					}
					var bodySize=_this.getBodySize(Atag);
					if(_this.arrTemp.length>=(bodySize+4))
					{
						for(i=0;i<(bodySize+4);i++)
						{
							Atag.push(_this.arrTemp.shift())
						}
						_this.arrMetaTag.push(Atag);
					}
					else
					{
						//如果包体没有那么大,就把临时数组还原,等下次再解析
						_this.arrTemp=Atag.concat(_this.arrTemp);
						return false;
					}
				}
				//拿出音频或者视频
				if(_this.arrMetaTag.length<4)
				{
					var Vtag=[];
					if(_this.arrTemp.length>11)
					{
						for(i=0;i<11;i++)
						{
							Vtag.push(_this.arrTemp.shift())
						}
					}
					else
					{
						return false;
					}
					var bodySize=_this.getBodySize(Vtag);
					if(_this.arrTemp.length>=(bodySize+4))
					{
						for(i=0;i<(bodySize+4);i++)
						{
							Vtag.push(_this.arrTemp.shift())
						}
						_this.arrMetaTag.push(Vtag);
						return true;
					}
					else
					{
						//如果包体没有那么大,就把临时数组还原,等下次再解析
						_this.arrTemp=Vtag.concat(_this.arrTemp);
						return false;
					}
				}
			}
			function getBodySize(arr){
				var a=arr[1].toString(16).length==1?"0"+arr[1].toString(16):arr[1].toString(16);
				var b=arr[2].toString(16).length==1?"0"+arr[2].toString(16):arr[2].toString(16);
				var c=arr[3].toString(16).length==1?"0"+arr[3].toString(16):arr[3].toString(16);
				return parseInt((a+""+b+""+c),16)
			}
			//获取完整的tag
			function getMAV(u8a){
				while(_this.decodeOpen){
					if(u8a.length>11)
					{
						_this.tempTag=[];
						for(var i=0;i<11;i++)
						{
							_this.tempTag.push(_this.arrTemp.shift())
						}
					}
					else
					{
						_this.decodeOpen=false;
						continue;
					}
					var bodySize=_this.getBodySize(_this.tempTag);
					if(_this.getBodySize(_this.tempTag)==35)
					{
						_this.getBodySize(_this.tempTag);
					}
					if(_this.arrTemp.length>=(bodySize+4))
					{
						for(i=0;i<(bodySize+4);i++)
						{
							_this.tempTag.push(_this.arrTemp.shift())
						}
//						arrTag.push(_this.tempTag);
					}
					else
					{
						//如果包体没有那么大,就把临时数组还原,等下次再解析
						_this.arrTemp=_this.tempTag.concat(_this.arrTemp);
						_this.decodeOpen=false;
						continue;
					}
//					arrTag.push(_this.tempTag);
					arrTag=arrTag.concat(_this.tempTag);
					
				}
			}
			var sourceBuffer;
			var firstRun=false;
			var mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
			function sourceOpen(){
				console.log("this's open",mediaSource.readyState);
				if(!firstRun)
				{
					
					sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
					sourceBuffer.addEventListener('error', () => console.log('sourceBuffer: error'));
					sourceBuffer.addEventListener('abort', () => console.log('sourceBuffer: abort'));
					sourceBuffer.addEventListener('updateend', () => {
						console.log('sourceBuffer: updateend')
						sourceBufferOnUpdateend();
					});
			
					sourceBuffer.addEventListener('update', () => {
						let ranges = [];
						let buffered = sourceBuffer.buffered;
						for (let i = 0; i < buffered.length; i++) {
							ranges.push([buffered.start(i), buffered.end(i)]);
						}
						console.log('bufupdate:', JSON.stringify(ranges), 'time', elem.currentTime);
			
						if (buffered.length > 0) {
							if (elem.currentTime < buffered.start(0) || 
									elem.currentTime > buffered.end(buffered.length-1)) 
							{
								elem.currentTime = buffered.start(0)+0.1;
							}
						}
					});
//					var r=new headers()
					//https://cors-anywhere.herokuapp.com/http://nickdesaulniers.github.io/netfix/demo/frag_bunny.mp4
					//https://cors-anywhere.herokuapp.com/http://dvr-ws.csslcloud.net/src/AE3C4B5BCABAA3AE9C33DC5901307461.flv
					//https://cors-anywhere.herokuapp.com/http://b1.33.play.bokecc.com/flvs/ca/QxhIP/uLfWP5TJ25-9.flv?t=1474632299&key=3757A088C3CBECE9F0773209CB3F67A8&upid=7762521474625099162&pt=0&pi=1&time_random=1474625099800_441138
					//http://gao11.cn/1.flv
					var req = new Request("http://dvr-ws.csslcloud.net/src/AE3C4B5BCABAA3AE9C33DC5901307461.flv", {method: 'GET', cache: 'default',mode:"cors"});  
				    fetch(req).then(function(response) {  
				    		//  typeof(response.body)==ReadableStream
				        var reader = response.body.getReader();  
				        return readr(reader);
				    })
				    firstRun=true;
			   	}
			}
			
			function Uint8Array2Array(u8a) {
				var arr = [];
				for (var i = 0; i < u8a.length; i++) {
					arr.push(u8a[i]);
				}
				return arr;
			}
		</script>
	</head>
	<body>
		<div style="width: 50%;height: 400px;margin: auto;background-color: black;">
			<video id="pchVideo" style="width: 100%;height: 100%;" >
				buzhichi 
			</video>
		</div>
		<div id="timeCurren" style="float: left;"></div>
		<div id="time" style="float: left;"></div>
	</body>
</html>
